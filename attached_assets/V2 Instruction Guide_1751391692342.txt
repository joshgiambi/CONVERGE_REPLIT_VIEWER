Complete Contour System Implementation Guide


Table of Contents

1. Core Data Types and Interfaces
1. DICOM Parsing and Contour Extraction
1. Coordinate System Management
1. Contour Storage and Management
1. Brush Tool Implementation
1. Polygon Operations with ClipperLib
1. Contour Rendering and Visualization
1. Contour Editing Tools
1. Integration with Medical Viewer
1. Complete Working Example


1. Core Data Types and Interfaces


1.1 Basic Types

// types/contour.ts
export interface Point {
  x: number;
  y: number;
}

export interface Point3D {
  x: number;
  y: number;
  z: number;
}

export interface DisplayPoint {
  x: number;
  y: number;
}

// Polygon ring (exterior or hole)
export type PolygonRing = Point[];

// Single polygon (exterior + holes)
export type Polygon = PolygonRing[];

// Multiple polygons per slice
export type MultiPolygon = Polygon[];

// All polygons for a structure across all slices
export type StructurePolygons = Map<number, MultiPolygon>;

// Contour data structure
export interface ContourData {
  id: string;
  slicePosition: number;
  slicingMode: SlicingMode;
  polygons: MultiPolygon;
  metadata: {
    sourceTime: number;
    modifiedTime: number;
    commitTime: number;
  };
}

// Structure data structure
export interface StructureData {
  id: string;
  name: string;
  roiNumber: number;
  roiType: string;
  color: [number, number, number];
  contours: Map<number, ContourData>;
  metadata: {
    sourceTime: number;
    modifiedTime: number;
    commitTime: number;
  };
}

// Slicing modes
export enum SlicingMode {
  I = 'I', // Sagittal
  J = 'J', // Coronal
  K = 'K'  // Axial
}

// Brush operations
export enum BrushOperation {
  ADDITIVE = 'ADDITIVE',
  SUBTRACTIVE = 'SUBTRACTIVE'
}

// Commit status
export enum CommitStatus {
  SOURCE = 'SOURCE',
  COMMITTED = 'COMMITTED',
  STAGED = 'STAGED'
}

1.2 DICOM Types

// types/dicom.ts
export interface DICOMImageMetadata {
  imagePositionPatient: [number, number, number];
  imageOrientationPatient: [number, number, number, number, number, number];
  pixelSpacing: [number, number];
  rows: number;
  columns: number;
  sliceThickness: number;
  sliceLocation: number;
  sopInstanceUID: string;
  sopClassUID: string;
}

export interface DICOMContourData {
  contourGeometricType: string;
  numberOfContourPoints: number;
  contourData: [number, number, number][];
  contourImageSequence: Array<{
    referencedSOPClassUID: string;
    referencedSOPInstanceUID: string;
  }>;
}

export interface DICOMROIContour {
  referencedROINumber: number;
  roiDisplayColor: [number, number, number];
  contourSequence: DICOMContourData[];
}

export interface DICOMStructureSetROI {
  roiNumber: number;
  roiName: string;
  referencedFrameOfReferenceUID: string;
  roiGenerationAlgorithm: string;
}

export interface DICOMRTROIObservation {
  observationNumber: number;
  referencedROINumber: number;
  rtROIInterpretedType: string;
}


2. DICOM Parsing and Contour Extraction


2.1 DICOM Parser Implementation

// utils/dicomParser.ts
import { DataSet, parseDicom } from "dicom-parser";

export class DICOMParser {
  private dataSet: DataSet;
  
  constructor(dicomBuffer: ArrayBuffer) {
    const uint8Array = new Uint8Array(dicomBuffer);
    this.dataSet = parseDicom(uint8Array);
  }
  
  // Extract string value from DICOM tag
  private getString(tag: string): string | undefined {
    const element = this.dataSet.elements[tag];
    if (!element) return undefined;
    
    if (element.vr === 'SQ') {
      return undefined;
    }
    
    return this.dataSet.string(tag);
  }
  
  // Extract integer value from DICOM tag
  private getInt(tag: string): number | undefined {
    const element = this.dataSet.elements[tag];
    if (!element) return undefined;
    
    return this.dataSet.intString(tag);
  }
  
  // Extract float array from DICOM tag
  private getFloatArray(tag: string): number[] | undefined {
    const element = this.dataSet.elements[tag];
    if (!element) return undefined;
    
    const stringValue = this.dataSet.string(tag);
    if (!stringValue) return undefined;
    
    return stringValue.split('\\').map(val => parseFloat(val));
  }
  
  // Parse sequence items
  private parseSequence(tag: string): any[] {
    const element = this.dataSet.elements[tag];
    if (!element || !element.items) return [];
    
    return element.items.map(item => {
      const sequenceDataSet = item.dataSet;
      if (!sequenceDataSet) return {};
      
      const result: any = {};
      for (const [tag, element] of Object.entries(sequenceDataSet.elements)) {
        if (element.vr === 'SQ') {
          result[tag] = this.parseSequence(tag);
        } else if (element.vr === 'DS' || element.vr === 'FL') {
          result[tag] = this.getFloatArray(tag);
        } else if (element.vr === 'IS' || element.vr === 'SL') {
          result[tag] = this.getInt(tag);
        } else {
          result[tag] = this.getString(tag);
        }
      }
      return result;
    });
  }
  
  // Parse Structure Set ROI Sequence
  parseStructureSetROISequence(): DICOMStructureSetROI[] {
    const sequence = this.parseSequence('30060020'); // StructureSetROISequence
    
    return sequence.map(item => ({
      roiNumber: item['30060022'] || -1,
      roiName: item['30060026'] || '',
      referencedFrameOfReferenceUID: item['30060024'] || '',
      roiGenerationAlgorithm: item['30060036'] || 'MANUAL',
    }));
  }
  
  // Parse ROI Contour Sequence
  parseROIContourSequence(): DICOMROIContour[] {
    const sequence = this.parseSequence('30060039'); // ROIContourSequence
    
    return sequence.map(item => {
      // Parse ROI Display Color
      const colorString = item['3006002A']; // ROIDisplayColor
      let roiDisplayColor: [number, number, number] = [255, 255, 255];
      
      if (colorString) {
        const colors = colorString.split('\\').map(c => parseInt(c));
        if (colors.length >= 3) {
          roiDisplayColor = [colors[0], colors[1], colors[2]];
        }
      }
      
      // Parse Contour Sequence
      const contourSequence = this.parseContourSequence(item['30060040']); // ContourSequence
      
      return {
        referencedROINumber: item['30060084'] || -1,
        roiDisplayColor,
        contourSequence,
      };
    });
  }
  
  // Parse individual Contour Sequence
  private parseContourSequence(contourItems: any[]): DICOMContourData[] {
    if (!contourItems || !Array.isArray(contourItems)) return [];
    
    return contourItems.map(item => {
      // Parse Contour Data - CRITICAL STEP
      const contourDataString = item['30060050']; // ContourData
      let contourData: [number, number, number][] = [];
      
      if (contourDataString) {
        const points = contourDataString.split('\\');
        contourData = [];
        
        // DICOM contour data is stored as x1\y1\z1\x2\y2\z2\...
        for (let i = 0; i < points.length; i += 3) {
          if (i + 2 < points.length) {
            contourData.push([
              parseFloat(points[i]),     // X coordinate
              parseFloat(points[i + 1]), // Y coordinate
              parseFloat(points[i + 2]), // Z coordinate
            ]);
          }
        }
      }
      
      // Parse Contour Image Sequence
      const imageSequence = this.parseImageSequence(item['30060016']); // ContourImageSequence
      
      return {
        contourGeometricType: item['30060042'] || 'CLOSED_PLANAR',
        numberOfContourPoints: item['30060046'] || contourData.length,
        contourData,
        contourImageSequence: imageSequence,
      };
    });
  }
  
  // Parse Contour Image Sequence
  private parseImageSequence(imageItems: any[]): Array<{
    referencedSOPClassUID: string;
    referencedSOPInstanceUID: string;
  }> {
    if (!imageItems || !Array.isArray(imageItems)) return [];
    
    return imageItems.map(item => ({
      referencedSOPClassUID: item['00081150'] || '',
      referencedSOPInstanceUID: item['00081155'] || '',
    }));
  }
  
  // Parse RT ROI Observations Sequence
  parseRTROIObservationsSequence(): DICOMRTROIObservation[] {
    const sequence = this.parseSequence('30060080'); // RTROIObservationsSequence
    
    return sequence.map(item => ({
      observationNumber: item['30060082'] || -1,
      referencedROINumber: item['30060084'] || -1,
      rtROIInterpretedType: item['300600A4'] || 'ORGAN',
    }));
  }
}

2.2 Contour Data Extractor

// utils/contourExtractor.ts
import { DICOMParser } from './dicomParser';
import { StructureData, ContourData, SlicingMode } from '../types/contour';
import { DICOMStructureSetROI, DICOMROIContour, DICOMRTROIObservation } from '../types/dicom';

export class ContourExtractor {
  private static readonly SCALING_FACTOR = 1000;
  
  static extractFromDICOM(dicomBuffer: ArrayBuffer): StructureData[] {
    const parser = new DICOMParser(dicomBuffer);
    
    // Parse all sequences
    const structureSetROIs = parser.parseStructureSetROISequence();
    const roiContours = parser.parseROIContourSequence();
    const roiObservations = parser.parseRTROIObservationsSequence();
    
    // Create lookup maps
    const roiContourMap = new Map(
      roiContours.map(roi => [roi.referencedROINumber, roi])
    );
    
    const roiObservationMap = new Map(
      roiObservations.map(obs => [obs.referencedROINumber, obs])
    );
    
    const structures: StructureData[] = [];
    
    // Process each structure
    for (const roi of structureSetROIs) {
      const roiContour = roiContourMap.get(roi.roiNumber);
      const roiObservation = roiObservationMap.get(roi.roiNumber);
      
      if (!roiContour) {
        console.warn(`No contour data found for ROI ${roi.roiNumber}`);
        continue;
      }
      
      // Create structure data
      const structureData: StructureData = {
        id: `structure-${roi.roiNumber}`,
        name: roi.roiName,
        roiNumber: roi.roiNumber,
        roiType: roiObservation?.rtROIInterpretedType || 'ORGAN',
        color: roiContour.roiDisplayColor,
        contours: new Map(),
        metadata: {
          sourceTime: Date.now(),
          modifiedTime: Date.now(),
          commitTime: Date.now()
        }
      };
      
      // Process contours for this structure
      for (const contour of roiContour.contourSequence) {
        if (!contour.contourData || contour.contourData.length === 0) {
          continue;
        }
        
        // Extract slice position from contour data
        const slicePosition = this.extractSlicePosition(contour.contourData);
        
        // Convert DICOM coordinates to polygons
        const polygons = this.convertDICOMCoordinatesToPolygons(contour.contourData);
        
        // Create contour data
        const contourData: ContourData = {
          id: `${structureData.id}-${slicePosition}`,
          slicePosition,
          slicingMode: SlicingMode.K, // Default to axial
          polygons,
          metadata: {
            sourceTime: Date.now(),
            modifiedTime: Date.now(),
            commitTime: Date.now()
          }
        };
        
        // Add to structure contours
        structureData.contours.set(slicePosition, contourData);
      }
      
      structures.push(structureData);
    }
    
    return structures;
  }
  
  private static extractSlicePosition(contourData: [number, number, number][]): number {
    if (contourData.length > 0) {
      return contourData[0][2]; // Z coordinate
    }
    return 0;
  }
  
  private static convertDICOMCoordinatesToPolygons(
    contourData: [number, number, number][]
  ): MultiPolygon {
    if (!contourData || contourData.length === 0) {
      return [];
    }
    
    // Group coordinates by contour (DICOM may have multiple contours per slice)
    const contours = this.groupCoordinatesByContour(contourData);
    
    const multiPolygon: MultiPolygon = [];
    
    for (const contour of contours) {
      // Convert to scaled coordinates
      const points: Point[] = contour.map(([x, y, z]) => ({
        x: Math.round(x * this.SCALING_FACTOR),
        y: Math.round(y * this.SCALING_FACTOR)
      }));
      
      // Create polygon ring (exterior)
      const polygon: Polygon = [points];
      
      // Check if polygon is valid
      if (this.isValidPolygon(points)) {
        multiPolygon.push(polygon);
      }
    }
    
    return multiPolygon;
  }
  
  private static groupCoordinatesByContour(
    coordinates: [number, number, number][]
  ): [number, number, number][][] {
    const contours: [number, number, number][][] = [];
    let currentContour: [number, number, number][] = [];
    
    for (const coord of coordinates) {
      currentContour.push(coord);
      
      // Check if contour is closed (first and last points are the same)
      if (currentContour.length > 3) {
        const first = currentContour[0];
        const last = currentContour[currentContour.length - 1];
        
        const distance = Math.sqrt(
          Math.pow(first[0] - last[0], 2) +
          Math.pow(first[1] - last[1], 2) +
          Math.pow(first[2] - last[2], 2)
        );
        
        if (distance < 0.1) { // 0.1mm tolerance
          contours.push([...currentContour]);
          currentContour = [];
        }
      }
    }
    
    // Add any remaining contour
    if (currentContour.length > 0) {
      contours.push(currentContour);
    }
    
    return contours;
  }
  
  private static isValidPolygon(points: Point[]): boolean {
    if (points.length < 3) return false;
    
    // Check if polygon is closed (first and last points are the same)
    const first = points[0];
    const last = points[points.length - 1];
    
    const distance = Math.sqrt(
      Math.pow(first.x - last.x, 2) + Math.pow(first.y - last.y, 2)
    );
    
    return distance < 1; // 1 pixel tolerance
  }
}


3. Coordinate System Management


3.1 Coordinate Transformer

// utils/coordinateTransformer.ts
import { Point, Point3D, DisplayPoint } from '../types/contour';
import { DICOMImageMetadata } from '../types/dicom';

export class CoordinateTransformer {
  private static readonly SCALING_FACTOR = 1000;
  
  // Convert patient coordinates to pixel coordinates
  static patientToPixel(
    patientCoord: Point3D,
    imageMetadata: DICOMImageMetadata
  ): { x: number; y: number; z: number } {
    const { imagePositionPatient, imageOrientationPatient, pixelSpacing } = imageMetadata;
    
    // Create transformation matrix from image orientation
    const rowCosine = [
      imageOrientationPatient[0],
      imageOrientationPatient[1], 
      imageOrientationPatient[2]
    ];
    const colCosine = [
      imageOrientationPatient[3],
      imageOrientationPatient[4],
      imageOrientationPatient[5]
    ];
    
    // Calculate normal vector (cross product of row and column cosines)
    const normal = this.crossProduct(rowCosine, colCosine);
    
    // Calculate vector from image position to patient point
    const vector = [
      patientCoord.x - imagePositionPatient[0],
      patientCoord.y - imagePositionPatient[1],
      patientCoord.z - imagePositionPatient[2]
    ];
    
    // Project vector onto row and column directions
    const rowProjection = this.dotProduct(vector, rowCosine);
    const colProjection = this.dotProduct(vector, colCosine);
    
    // Convert to pixel coordinates
    const pixelX = rowProjection / pixelSpacing[0];
    const pixelY = colProjection / pixelSpacing[1];
    
    // Calculate slice position
    const sliceZ = this.dotProduct(vector, normal) / imageMetadata.sliceThickness;
    
    return {
      x: pixelX,
      y: pixelY,
      z: sliceZ
    };
  }
  
  // Convert pixel coordinates to patient coordinates
  static pixelToPatient(
    pixelCoord: { x: number; y: number; z: number },
    imageMetadata: DICOMImageMetadata
  ): Point3D {
    const { imagePositionPatient, imageOrientationPatient, pixelSpacing } = imageMetadata;
    
    // Create transformation matrix
    const rowCosine = [
      imageOrientationPatient[0],
      imageOrientationPatient[1], 
      imageOrientationPatient[2]
    ];
    const colCosine = [
      imageOrientationPatient[3],
      imageOrientationPatient[4],
      imageOrientationPatient[5]
    ];
    
    // Calculate normal vector
    const normal = this.crossProduct(rowCosine, colCosine);
    
    // Calculate patient position
    const rowOffset = rowCosine.map(c => c * pixelCoord.x * pixelSpacing[0]);
    const colOffset = colCosine.map(c => c * pixelCoord.y * pixelSpacing[1]);
    const sliceOffset = normal.map(c => c * pixelCoord.z * imageMetadata.sliceThickness);
    
    return {
      x: imagePositionPatient[0] + rowOffset[0] + colOffset[0] + sliceOffset[0],
      y: imagePositionPatient[1] + rowOffset[1] + colOffset[1] + sliceOffset[1],
      z: imagePositionPatient[2] + rowOffset[2] + colOffset[2] + sliceOffset[2]
    };
  }
  
  // Convert world coordinates to scaled integer coordinates (for polygon operations)
  static worldToScaled(worldCoord: Point): { x: number; y: number } {
    return {
      x: Math.round(worldCoord.x * this.SCALING_FACTOR),
      y: Math.round(worldCoord.y * this.SCALING_FACTOR)
    };
  }
  
  // Convert scaled integer coordinates back to world coordinates
  static scaledToWorld(scaledCoord: { x: number; y: number }): Point {
    return {
      x: scaledCoord.x / this.SCALING_FACTOR,
      y: scaledCoord.y / this.SCALING_FACTOR
    };
  }
  
  // Convert world coordinates to display coordinates (for rendering)
  static worldToDisplay(
    worldCoord: Point,
    viewport: {
      camera: { position: [number, number, number]; viewUp: [number, number, number] };
      renderer: { getSize: () => [number, number] };
    }
  ): DisplayPoint {
    const [width, height] = viewport.renderer.getSize();
    
    // Simple orthographic projection (you'll need to implement proper projection)
    const x = (worldCoord.x + 1) * width / 2;
    const y = height - (worldCoord.y + 1) * height / 2; // Flip Y axis
    
    return { x, y };
  }
  
  // Utility functions
  private static crossProduct(a: number[], b: number[]): number[] {
    return [
      a[1] * b[2] - a[2] * b[1],
      a[2] * b[0] - a[0] * b[2],
      a[0] * b[1] - a[1] * b[0]
    ];
  }
  
  private static dotProduct(a: number[], b: number[]): number {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
}


4. Contour Storage and Management


4.1 Contour Class

// classes/Contour.ts
import { Point, Polygon, MultiPolygon, SlicingMode, CommitStatus } from '../types/contour';
import { CoordinateTransformer } from '../utils/coordinateTransformer';

export class Contour {
  private id: string;
  private slicePosition: number;
  private slicingMode: SlicingMode;
  private polygons: MultiPolygon;
  private needsUpdate: boolean = true;
  private commitStatus: CommitStatus = CommitStatus.SOURCE;
  
  constructor(
    structureId: string,
    slicePosition: number,
    slicingMode: SlicingMode,
    patientCoordinates: [number, number, number][],
    imageMetadata?: any
  ) {
    this.id = `${structureId}-${slicePosition}`;
    this.slicePosition = slicePosition;
    this.slicingMode = slicingMode;
    
    // Convert patient coordinates to polygons
    this.polygons = this.convertPatientCoordinatesToPolygons(
      patientCoordinates,
      imageMetadata
    );
  }
  
  private convertPatientCoordinatesToPolygons(
    patientCoords: [number, number, number][],
    imageMetadata?: any
  ): MultiPolygon {
    if (!patientCoords || patientCoords.length === 0) {
      return [];
    }
    
    // Group coordinates by contour (DICOM may have multiple contours per slice)
    const contours = this.groupCoordinatesByContour(patientCoords);
    
    const multiPolygon: MultiPolygon = [];
    
    for (const contour of contours) {
      // Convert to appropriate coordinate system based on slicing mode
      const points: Point[] = this.convertToSliceCoordinates(contour, imageMetadata);
      
      // Create polygon ring (exterior)
      const polygon: Polygon = [points];
      
      // Check if polygon is valid (at least 3 points, closed)
      if (this.isValidPolygon(points)) {
        multiPolygon.push(polygon);
      }
    }
    
    return multiPolygon;
  }
  
  private groupCoordinatesByContour(
    coordinates: [number, number, number][]
  ): [number, number, number][][] {
    const contours: [number, number, number][][] = [];
    let currentContour: [number, number, number][] = [];
    
    for (const coord of coordinates) {
      currentContour.push(coord);
      
      // Check if contour is closed (first and last points are the same)
      if (currentContour.length > 3) {
        const first = currentContour[0];
        const last = currentContour[currentContour.length - 1];
        
        const distance = Math.sqrt(
          Math.pow(first[0] - last[0], 2) +
          Math.pow(first[1] - last[1], 2) +
          Math.pow(first[2] - last[2], 2)
        );
        
        if (distance < 0.1) { // 0.1mm tolerance
          contours.push([...currentContour]);
          currentContour = [];
        }
      }
    }
    
    // Add any remaining contour
    if (currentContour.length > 0) {
      contours.push(currentContour);
    }
    
    return contours;
  }
  
  private convertToSliceCoordinates(
    contour: [number, number, number][],
    imageMetadata?: any
  ): Point[] {
    const points: Point[] = [];
    
    for (const [x, y, z] of contour) {
      let point: Point;
      
      switch (this.slicingMode) {
        case SlicingMode.K: // Axial slice (XY plane)
          point = { x, y };
          break;
        case SlicingMode.J: // Sagittal slice (XZ plane)
          point = { x, z };
          break;
        case SlicingMode.I: // Coronal slice (YZ plane)
          point = { y, z };
          break;
        default:
          point = { x, y };
      }
      
      // Scale for integer precision
      point = CoordinateTransformer.worldToScaled(point);
      points.push(point);
    }
    
    return points;
  }
  
  private isValidPolygon(points: Point[]): boolean {
    if (points.length < 3) return false;
    
    // Check if polygon is closed (first and last points are the same)
    const first = points[0];
    const last = points[points.length - 1];
    
    const distance = Math.sqrt(
      Math.pow(first.x - last.x, 2) + Math.pow(first.y - last.y, 2)
    );
    
    return distance < 1; // 1 pixel tolerance
  }
  
  // Get current polygon data
  getCurrent(): MultiPolygon {
    return this.polygons;
  }
  
  // Get number of polygons
  get numberOfPolygons(): number {
    return this.polygons.reduce((acc, polygon) => acc + polygon.length, 0);
  }
  
  // Get number of points
  get numberOfPoints(): number {
    return this.polygons.reduce((acc, polygon) => 
      acc + polygon.reduce((sum, ring) => sum + ring.length, 0), 0
    );
  }
  
  // Get slice position
  getPosition(): number {
    return this.slicePosition;
  }
  
  // Get slicing mode
  getSlicingMode(): SlicingMode {
    return this.slicingMode;
  }
  
  // Add polygon
  addPolygon(points: Point[]): void {
    if (this.isValidPolygon(points)) {
      this.polygons.push([points]);
      this.needsUpdate = true;
      this.commitStatus = CommitStatus.STAGED;
    }
  }
  
  // Remove polygon
  removePolygon(index: number): void {
    if (index >= 0 && index < this.polygons.length) {
      this.polygons.splice(index, 1);
      this.needsUpdate = true;
      this.commitStatus = CommitStatus.STAGED;
    }
  }
  
  // Get centroid
  getCentroid(): Point {
    if (this.polygons.length === 0) return { x: 0, y: 0 };
    
    let totalX = 0;
    let totalY = 0;
    let totalPoints = 0;
    
    for (const polygon of this.polygons) {
      for (const ring of polygon) {
        for (const point of ring) {
          totalX += point.x;
          totalY += point.y;
          totalPoints++;
        }
      }
    }
    
    return {
      x: totalX / totalPoints,
      y: totalY / totalPoints
    };
  }
  
  // Get bounding box
  getBounds(): { minX: number; minY: number; maxX: number; maxY: number } {
    if (this.polygons.length === 0) {
      return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
    }
    
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    
    for (const polygon of this.polygons) {
      for (const ring of polygon) {
        for (const point of ring) {
          minX = Math.min(minX, point.x);
          minY = Math.min(minY, point.y);
          maxX = Math.max(maxX, point.x);
          maxY = Math.max(maxY, point.y);
        }
      }
    }
    
    return { minX, minY, maxX, maxY };
  }
  
  // Convert to SVG paths for rendering
  toSVGPaths(): string[] {
    const paths: string[] = [];
    
    for (const polygon of this.polygons) {
      for (const ring of polygon) {
        if (ring.length < 3) continue;
        
        let path = `M${ring[0].x},${ring[0].y}`;
        
        for (let i = 1; i < ring.length; i++) {
          path += ` L${ring[i].x},${ring[i].y}`;
        }
        
        path += ' Z'; // Close path
        paths.push(path);
      }
    }
    
    return paths;
  }
  
  // Convert to display points for rendering
  toDisplayPoints(viewport: any): DisplayPoint[][] {
    const displayPoints: DisplayPoint[][] = [];
    
    for (const polygon of this.polygons) {
      const polygonDisplayPoints: DisplayPoint[][] = [];
      
      for (const ring of polygon) {
        const ringDisplayPoints: DisplayPoint[] = ring.map(point => {
          const worldPoint = CoordinateTransformer.scaledToWorld(point);
          return CoordinateTransformer.worldToDisplay(worldPoint, viewport);
        });
        
        polygonDisplayPoints.push(ringDisplayPoints);
      }
      
      displayPoints.push(...polygonDisplayPoints);
    }
    
    return displayPoints;
  }
  
  // Clone contour
  clone(): Contour {
    const cloned = new Contour(
      this.id.split('-')[0], // Extract structure ID
      this.slicePosition,
      this.slicingMode,
      [] // Empty coordinates since we'll copy polygons directly
    );
    
    // Deep copy polygons
    cloned.polygons = JSON.parse(JSON.stringify(this.polygons));
    
    return cloned;
  }
  
  // Commit changes
  commit(): void {
    this.commitStatus = CommitStatus.COMMITTED;
    this.needsUpdate = false;
  }
  
  // Get commit status
  getCommitStatus(): CommitStatus {
    return this.commitStatus;
  }
  
  // Check if needs update
  get needsUpdate(): boolean {
    return this._needsUpdate;
  }
  
  set needsUpdate(value: boolean) {
    this._needsUpdate = value;
  }
}

4.2 Structure Set Entity

// classes/StructureSetEntity.ts
import { StructureData, ContourData, SlicingMode } from '../types/contour';
import { Contour } from './Contour';
import { ContourExtractor } from '../utils/contourExtractor';

export class StructureSetEntity {
  private id: string;
  private structures: Map<string, StructureData>;
  private metadata: {
    sourceTime: number;
    modifiedTime: number;
    commitTime: number;
  };
  
  constructor(id: string) {
    this.id = id;
    this.structures = new Map();
    this.metadata = {
      sourceTime: 0,
      modifiedTime: 0,
      commitTime: 0
    };
  }
  
  // Load structure set from DICOM file
  async loadFromDICOM(dicomBuffer: ArrayBuffer): Promise<void> {
    const structures = ContourExtractor.extractFromDICOM(dicomBuffer);
    
    for (const structure of structures) {
      this.structures.set(structure.id, structure);
    }
    
    this.metadata.modifiedTime = Date.now();
  }
  
  // Get structure by ID
  getStructure(structureId: string): StructureData | undefined {
    return this.structures.get(structureId);
  }
  
  // Get all structures
  getAllStructures(): StructureData[] {
    return Array.from(this.structures.values());
  }
  
  // Get contour for specific structure and slice
  getContourAtSlice(
    structureId: string,
    slicePosition: number,
    slicingMode: SlicingMode = SlicingMode.K
  ): Contour | undefined {
    const structure = this.structures.get(structureId);
    if (!structure) return undefined;
    
    // Find closest slice position
    const slicePositions = Array.from(structure.contours.keys());
    const closestSlice = this.findClosestSlice(slicePositions, slicePosition);
    
    if (closestSlice === undefined) return undefined;
    
    const contourData = structure.contours.get(closestSlice);
    if (!contourData) return undefined;
    
    return new Contour(
      structureId,
      closestSlice,
      slicingMode,
      [], // Empty coordinates since we have polygons
    );
  }
  
  private findClosestSlice(slicePositions: number[], targetPosition: number): number | undefined {
    if (slicePositions.length === 0) return undefined;
    
    let closest = slicePositions[0];
    let minDistance = Math.abs(closest - targetPosition);
    
    for (const position of slicePositions) {
      const distance = Math.abs(position - targetPosition);
      if (distance < minDistance) {
        minDistance = distance;
        closest = position;
      }
    }
    
    // Return closest if within tolerance (1mm)
    return minDistance <= 1.0 ? closest : undefined;
  }
  
  // Add new structure
  addStructure(structureData: StructureData): void {
    this.structures.set(structureData.id, structureData);
    this.metadata.modifiedTime = Date.now();
  }
  
  // Remove structure
  removeStructure(structureId: string): boolean {
    const removed = this.structures.delete(structureId);
    if (removed) {
      this.metadata.modifiedTime = Date.now();
    }
    return removed;
  }
  
  // Get metadata
  getMetadata() {
    return { ...this.metadata };
  }
  
  // Set metadata
  setMetadata(metadata: Partial<typeof this.metadata>): void {
    this.metadata = { ...this.metadata, ...metadata };
  }
}


5. Brush Tool Implementation


5.1 Brush Tool Base Class

// tools/BrushTool.ts
import { Point, MultiPolygon, BrushOperation, SlicingMode } from '../types/contour';
import { ClipperLib, ClipType, JoinType, EndType, PolyFillType, PointInPolygonResult } from 'js-angusj-clipper/web';

export abstract class BrushTool {
  protected brushSize: number = 30;
  protected operation: BrushOperation = BrushOperation.ADDITIVE;
  protected lastPosition: Point | undefined;
  protected isDrawing: boolean = false;
  protected targetContour: any; // Contour object
  
  constructor() {
    this.initializeClipperLib();
  }
  
  private async initializeClipperLib(): Promise<void> {
    // Ensure ClipperLib is loaded
    if (!ClipperLib) {
      throw new Error('ClipperLib not available');
    }
  }
  
  // Set brush size
  setBrushSize(size: number): void {
    this.brushSize = Math.max(1, Math.min(100, size));
  }
  
  // Get brush size
  getBrushSize(): number {
    return this.brushSize;
  }
  
  // Set operation mode
  setOperation(operation: BrushOperation): void {
    this.operation = operation;
  }
  
  // Get operation mode
  getOperation(): BrushOperation {
    return this.operation;
  }
  
  // Create brush circle
  protected createBrushCircle(center: Point, radius: number, steps = 32): Point[] {
    const points: Point[] = [];
    for (let i = 0; i < steps; i++) {
      const angle = (i / steps) * Math.PI * 2;
      points.push({
        x: Math.round(center.x + Math.cos(angle) * radius),
        y: Math.round(center.y + Math.sin(angle) * radius),
      });
    }
    points.push(points[0]); // Close the ring
    return points;
  }
  
  // Create brush stroke path
  protected createBrushStrokePath(startPoint: Point, endPoint: Point, radius: number): Point[] {
    // Create a line between start and end points
    const line: Point[] = [
      { x: Math.round(startPoint.x), y: Math.round(startPoint.y) },
      { x: Math.round(endPoint.x), y: Math.round(endPoint.y) }
    ];
    
    // Offset the line to create a brush stroke
    const result = ClipperLib.offsetToPolyTree({
      delta: radius,
      offsetInputs: [{
        data: line,
        joinType: JoinType.Round,
        endType: EndType.OpenRound
      }]
    });
    
    const resultPaths = ClipperLib.polyTreeToPaths(result);
    if (resultPaths.length > 0) {
      return resultPaths[0];
    }
    
    return [];
  }
  
  // Perform boolean operation
  protected performBooleanOperation(
    subjectPolygons: MultiPolygon,
    brushPolygons: MultiPolygon
  ): MultiPolygon {
    const clipType = this.operation === BrushOperation.ADDITIVE 
      ? ClipType.Union 
      : ClipType.Difference;
    
    const result = ClipperLib.clipToPolyTree({
      clipType,
      subjectInputs: subjectPolygons.map(ring => ({ data: ring, closed: true })),
      clipInputs: brushPolygons.map(ring => ({ data: ring, closed: true })),
      subjectFillType: PolyFillType.NonZero,
    });
    
    let resultPaths = ClipperLib.polyTreeToPaths(result);
    resultPaths = ClipperLib.cleanPolygons(resultPaths, 2);
    resultPaths = ClipperLib.simplifyPolygons(resultPaths, PolyFillType.NonZero);
    
    return resultPaths;
  }
  
  // Check if point is inside polygon
  protected isPointInPolygon(point: Point, polygons: MultiPolygon): boolean {
    let insideCount = 0;
    
    for (const polygon of polygons) {
      for (const ring of polygon) {
        const result = ClipperLib.pointInPolygon(point, ring);
        if (result === PointInPolygonResult.Inside) {
          insideCount++;
        }
      }
    }
    
    // Odd number of insides = point is inside (NonZero rule)
    return insideCount % 2 === 1;
  }
  
  // Abstract methods to be implemented by concrete brush tools
  abstract onMouseDown(event: MouseEvent): void;
  abstract onMouseMove(event: MouseEvent): void;
  abstract onMouseUp(event: MouseEvent): void;
  abstract render(context: CanvasRenderingContext2D): void;
}

5.2 Circle Brush Tool

// tools/CircleBrushTool.ts
import { BrushTool } from './BrushTool';
import { Point, MultiPolygon } from '../types/contour';

export class CircleBrushTool extends BrushTool {
  private currentPosition: Point | undefined;
  
  onMouseDown(event: MouseEvent): void {
    this.isDrawing = true;
    this.currentPosition = { x: event.offsetX, y: event.offsetY };
    this.lastPosition = this.currentPosition;
    
    // Apply brush stroke
    this.applyBrushStroke();
  }
  
  onMouseMove(event: MouseEvent): void {
    if (!this.isDrawing) return;
    
    this.currentPosition = { x: event.offsetX, y: event.offsetY };
    
    // Apply brush stroke
    this.applyBrushStroke();
    
    this.lastPosition = this.currentPosition;
  }
  
  onMouseUp(event: MouseEvent): void {
    this.isDrawing = false;
    this.lastPosition = undefined;
  }
  
  private applyBrushStroke(): void {
    if (!this.currentPosition || !this.targetContour) return;
    
    // Create brush circle
    const brushCircle = this.createBrushCircle(this.currentPosition, this.brushSize / 2);
    const brushPolygons: MultiPolygon = [brushCircle];
    
    // Get current contour polygons
    const currentPolygons = this.targetContour.getCurrent();
    
    // Perform boolean operation
    const resultPolygons = this.performBooleanOperation(currentPolygons, brushPolygons);
    
    // Update contour
    this.targetContour.updatePolygons(resultPolygons);
  }
  
  render(context: CanvasRenderingContext2D): void {
    if (!this.currentPosition) return;
    
    // Draw brush circle
    context.save();
    context.strokeStyle = this.operation === 'ADDITIVE' ? '#00ff00' : '#ff0000';
    context.lineWidth = 2;
    context.setLineDash([5, 5]);
    
    context.beginPath();
    context.arc(this.currentPosition.x, this.currentPosition.y, this.brushSize / 2, 0, 2 * Math.PI);
    context.stroke();
    
    // Draw crosshair
    const size = 5;
    context.setLineDash([]);
    context.beginPath();
    context.moveTo(this.currentPosition.x - size, this.currentPosition.y);
    context.lineTo(this.currentPosition.x + size, this.currentPosition.y);
    context.moveTo(this.currentPosition.x, this.currentPosition.y - size);
    context.lineTo(this.currentPosition.x, this.currentPosition.y + size);
    context.stroke();
    
    context.restore();
  }
}

5.3 Path Brush Tool

// tools/PathBrushTool.ts
import { BrushTool } from './BrushTool';
import { Point, MultiPolygon } from '../types/contour';

export class PathBrushTool extends BrushTool {
  private currentPosition: Point | undefined;
  private pathPoints: Point[] = [];
  
  onMouseDown(event: MouseEvent): void {
    this.isDrawing = true;
    this.currentPosition = { x: event.offsetX, y: event.offsetY };
    this.lastPosition = this.currentPosition;
    this.pathPoints = [this.currentPosition];
  }
  
  onMouseMove(event: MouseEvent): void {
    if (!this.isDrawing) return;
    
    this.currentPosition = { x: event.offsetX, y: event.offsetY };
    this.pathPoints.push(this.currentPosition);
    
    // Apply brush stroke for current segment
    if (this.lastPosition) {
      this.applyBrushStroke(this.lastPosition, this.currentPosition);
    }
    
    this.lastPosition = this.currentPosition;
  }
  
  onMouseUp(event: MouseEvent): void {
    this.isDrawing = false;
    this.lastPosition = undefined;
    this.pathPoints = [];
  }
  
  private applyBrushStroke(startPoint: Point, endPoint: Point): void {
    if (!this.targetContour) return;
    
    // Create brush stroke path
    const brushStroke = this.createBrushStrokePath(startPoint, endPoint, this.brushSize / 2);
    if (brushStroke.length === 0) return;
    
    const brushPolygons: MultiPolygon = [brushStroke];
    
    // Get current contour polygons
    const currentPolygons = this.targetContour.getCurrent();
    
    // Perform boolean operation
    const resultPolygons = this.performBooleanOperation(currentPolygons, brushPolygons);
    
    // Update contour
    this.targetContour.updatePolygons(resultPolygons);
  }
  
  render(context: CanvasRenderingContext2D): void {
    if (!this.currentPosition) return;
    
    // Draw brush path
    context.save();
    context.strokeStyle = this.operation === 'ADDITIVE' ? '#00ff00' : '#ff0000';
    context.lineWidth = this.brushSize;
    context.lineCap = 'round';
    context.lineJoin = 'round';
context.globalAlpha = 0.3;
    
    if (this.pathPoints.length > 1) {
      context.beginPath();
      context.moveTo(this.pathPoints[0].x, this.pathPoints[0].y);
      
      for (let i = 1; i < this.pathPoints.length; i++) {
        context.lineTo(this.pathPoints[i].x, this.pathPoints[i].y);
      }
      
      context.stroke();
    }
    
    // Draw current brush circle
    context.globalAlpha = 1;
    context.setLineDash([5, 5]);
    context.lineWidth = 2;
    
    context.beginPath();
    context.arc(this.currentPosition.x, this.currentPosition.y, this.brushSize / 2, 0, 2 * Math.PI);
    context.stroke();
    
    // Draw crosshair
    const size = 5;
    context.setLineDash([]);
    context.beginPath();
    context.moveTo(this.currentPosition.x - size, this.currentPosition.y);
    context.lineTo(this.currentPosition.x + size, this.currentPosition.y);
    context.moveTo(this.currentPosition.x, this.currentPosition.y - size);
    context.lineTo(this.currentPosition.x, this.currentPosition.y + size);
    context.stroke();
    
    context.restore();
  }
}

5.4 Intelligent Brush Tool

// tools/IntelligentBrushTool.ts
import { BrushTool } from './BrushTool';
import { Point, MultiPolygon } from '../types/contour';

export class IntelligentBrushTool extends BrushTool {
  private currentPosition: Point | undefined;
  private pathPoints: Point[] = [];
  
  onMouseDown(event: MouseEvent): void {
    this.isDrawing = true;
    this.currentPosition = { x: event.offsetX, y: event.offsetY };
    this.lastPosition = this.currentPosition;
    this.pathPoints = [this.currentPosition];
    
    // Determine operation based on current position
    this.determineOperation();
  }
  
  onMouseMove(event: MouseEvent): void {
    if (!this.isDrawing) return;
    
    this.currentPosition = { x: event.offsetX, y: event.offsetY };
    this.pathPoints.push(this.currentPosition);
    
    // Apply brush stroke for current segment
    if (this.lastPosition) {
      this.applyBrushStroke(this.lastPosition, this.currentPosition);
    }
    
    this.lastPosition = this.currentPosition;
  }
  
  onMouseUp(event: MouseEvent): void {
    this.isDrawing = false;
    this.lastPosition = undefined;
    this.pathPoints = [];
  }
  
  private determineOperation(): void {
    if (!this.currentPosition || !this.targetContour) return;
    
    const currentPolygons = this.targetContour.getCurrent();
    
    // Check if point is inside existing contour
    const isInside = this.isPointInPolygon(this.currentPosition, currentPolygons);
    
    // Intelligent operation selection:
    // - If inside contour: Additive (fills holes)
    // - If outside contour: Subtractive (removes areas)
    // - Can be overridden with Shift key
    if (event.shiftKey) {
      this.operation = isInside ? BrushOperation.SUBTRACTIVE : BrushOperation.ADDITIVE;
    } else {
      this.operation = isInside ? BrushOperation.ADDITIVE : BrushOperation.SUBTRACTIVE;
    }
  }
  
  private applyBrushStroke(startPoint: Point, endPoint: Point): void {
    if (!this.targetContour) return;
    
    // Create brush stroke path
    const brushStroke = this.createBrushStrokePath(startPoint, endPoint, this.brushSize / 2);
    if (brushStroke.length === 0) return;
    
    const brushPolygons: MultiPolygon = [brushStroke];
    
    // Get current contour polygons
    const currentPolygons = this.targetContour.getCurrent();
    
    // Perform boolean operation
    const resultPolygons = this.performBooleanOperation(currentPolygons, brushPolygons);
    
    // Update contour
    this.targetContour.updatePolygons(resultPolygons);
  }
  
  render(context: CanvasRenderingContext2D): void {
    if (!this.currentPosition) return;
    
    // Draw brush path
    context.save();
    context.strokeStyle = this.operation === 'ADDITIVE' ? '#00ff00' : '#ff0000';
    context.lineWidth = this.brushSize;
    context.lineCap = 'round';
    context.lineJoin = 'round';
    context.globalAlpha = 0.3;
    
    if (this.pathPoints.length > 1) {
      context.beginPath();
      context.moveTo(this.pathPoints[0].x, this.pathPoints[0].y);
      
      for (let i = 1; i < this.pathPoints.length; i++) {
        context.lineTo(this.pathPoints[i].x, this.pathPoints[i].y);
      }
      
      context.stroke();
    }
    
    // Draw current brush circle
    context.globalAlpha = 1;
    context.setLineDash([5, 5]);
    context.lineWidth = 2;
    
    context.beginPath();
    context.arc(this.currentPosition.x, this.currentPosition.y, this.brushSize / 2, 0, 2 * Math.PI);
    context.stroke();
    
    // Draw operation indicator
    const size = 5;
    context.setLineDash([]);
    context.beginPath();
    
    if (this.operation === 'ADDITIVE') {
      // Draw cross for additive
      context.moveTo(this.currentPosition.x - size, this.currentPosition.y);
      context.lineTo(this.currentPosition.x + size, this.currentPosition.y);
      context.moveTo(this.currentPosition.x, this.currentPosition.y - size);
      context.lineTo(this.currentPosition.x, this.currentPosition.y + size);
    } else {
      // Draw horizontal line for subtractive
      context.moveTo(this.currentPosition.x - size, this.currentPosition.y);
      context.lineTo(this.currentPosition.x + size, this.currentPosition.y);
    }
    
    context.stroke();
    
    context.restore();
  }
}


6. Polygon Operations with ClipperLib


6.1 Polygon Operations Manager

// utils/polygonOperations.ts
import { ClipperLib, ClipType, JoinType, EndType, PolyFillType, PointInPolygonResult } from 'js-angusj-clipper/web';
import { Point, MultiPolygon } from '../types/contour';

export class PolygonOperations {
  private static readonly SCALING_FACTOR = 1000;
  
  // Scale coordinates for ClipperLib
  private static scaleCoordinates(polygons: MultiPolygon): MultiPolygon {
    return polygons.map(polygon => 
      polygon.map(ring => 
        ring.map(point => ({
          x: Math.round(point.x * this.SCALING_FACTOR),
          y: Math.round(point.y * this.SCALING_FACTOR)
        }))
      )
    );
  }
  
  // Unscale coordinates from ClipperLib
  private static unscaleCoordinates(polygons: MultiPolygon): MultiPolygon {
    return polygons.map(polygon => 
      polygon.map(ring => 
        ring.map(point => ({
          x: point.x / this.SCALING_FACTOR,
          y: point.y / this.SCALING_FACTOR
        }))
      )
    );
  }
  
  // Union operation
  static union(polygons1: MultiPolygon, polygons2: MultiPolygon): MultiPolygon {
    const scaled1 = this.scaleCoordinates(polygons1);
    const scaled2 = this.scaleCoordinates(polygons2);
    
    const result = ClipperLib.clipToPolyTree({
      clipType: ClipType.Union,
      subjectInputs: scaled1.map(ring => ({ data: ring, closed: true })),
      clipInputs: scaled2.map(ring => ({ data: ring, closed: true })),
      subjectFillType: PolyFillType.NonZero,
    });
    
    let resultPaths = ClipperLib.polyTreeToPaths(result);
    resultPaths = ClipperLib.cleanPolygons(resultPaths, 2);
    resultPaths = ClipperLib.simplifyPolygons(resultPaths, PolyFillType.NonZero);
    
    return this.unscaleCoordinates(resultPaths);
  }
  
  // Difference operation
  static difference(polygons1: MultiPolygon, polygons2: MultiPolygon): MultiPolygon {
    const scaled1 = this.scaleCoordinates(polygons1);
    const scaled2 = this.scaleCoordinates(polygons2);
    
    const result = ClipperLib.clipToPolyTree({
      clipType: ClipType.Difference,
      subjectInputs: scaled1.map(ring => ({ data: ring, closed: true })),
      clipInputs: scaled2.map(ring => ({ data: ring, closed: true })),
      subjectFillType: PolyFillType.NonZero,
    });
    
    let resultPaths = ClipperLib.polyTreeToPaths(result);
    resultPaths = ClipperLib.cleanPolygons(resultPaths, 2);
    resultPaths = ClipperLib.simplifyPolygons(resultPaths, PolyFillType.NonZero);
    
    return this.unscaleCoordinates(resultPaths);
  }
  
  // Intersection operation
  static intersection(polygons1: MultiPolygon, polygons2: MultiPolygon): MultiPolygon {
    const scaled1 = this.scaleCoordinates(polygons1);
    const scaled2 = this.scaleCoordinates(polygons2);
    
    const result = ClipperLib.clipToPolyTree({
      clipType: ClipType.Intersection,
      subjectInputs: scaled1.map(ring => ({ data: ring, closed: true })),
      clipInputs: scaled2.map(ring => ({ data: ring, closed: true })),
      subjectFillType: PolyFillType.NonZero,
    });
    
    let resultPaths = ClipperLib.polyTreeToPaths(result);
    resultPaths = ClipperLib.cleanPolygons(resultPaths, 2);
    resultPaths = ClipperLib.simplifyPolygons(resultPaths, PolyFillType.NonZero);
    
    return this.unscaleCoordinates(resultPaths);
  }
  
  // Offset operation (for brush strokes)
  static offset(polygons: MultiPolygon, delta: number): MultiPolygon {
    const scaled = this.scaleCoordinates(polygons);
    const scaledDelta = Math.round(delta * this.SCALING_FACTOR);
    
    const result = ClipperLib.offsetToPolyTree({
      delta: scaledDelta,
      offsetInputs: scaled.map(ring => ({
        data: ring,
        joinType: JoinType.Round,
        endType: EndType.ClosedPolygon
      }))
    });
    
    let resultPaths = ClipperLib.polyTreeToPaths(result);
    resultPaths = ClipperLib.cleanPolygons(resultPaths, 2);
    
    return this.unscaleCoordinates(resultPaths);
  }
  
  // Point-in-polygon test
  static isPointInPolygon(point: Point, polygons: MultiPolygon): boolean {
    const scaledPoint = {
      x: Math.round(point.x * this.SCALING_FACTOR),
      y: Math.round(point.y * this.SCALING_FACTOR)
    };
    
    const scaledPolygons = this.scaleCoordinates(polygons);
    
    let insideCount = 0;
    for (const polygon of scaledPolygons) {
      for (const ring of polygon) {
        const result = ClipperLib.pointInPolygon(scaledPoint, ring);
        if (result === PointInPolygonResult.Inside) {
          insideCount++;
        }
      }
    }
    
    return insideCount % 2 === 1;
  }
  
  // Create brush circle
  static createBrushCircle(center: Point, radius: number, steps = 32): MultiPolygon {
    const points: Point[] = [];
    for (let i = 0; i < steps; i++) {
      const angle = (i / steps) * Math.PI * 2;
      points.push({
        x: center.x + Math.cos(angle) * radius,
        y: center.y + Math.sin(angle) * radius,
      });
    }
    points.push(points[0]); // Close the ring
    
    return [[points]];
  }
  
  // Create brush stroke path
  static createBrushStrokePath(startPoint: Point, endPoint: Point, radius: number): MultiPolygon {
    const line: Point[] = [startPoint, endPoint];
    const scaledLine = this.scaleCoordinates([[line]]);
    const scaledRadius = Math.round(radius * this.SCALING_FACTOR);
    
    const result = ClipperLib.offsetToPolyTree({
      delta: scaledRadius,
      offsetInputs: [{
        data: scaledLine[0][0],
        joinType: JoinType.Round,
        endType: EndType.OpenRound
      }]
    });
    
    let resultPaths = ClipperLib.polyTreeToPaths(result);
    resultPaths = ClipperLib.cleanPolygons(resultPaths, 2);
    
    return this.unscaleCoordinates(resultPaths);
  }
  
  // Validate polygon
  static validatePolygon(polygon: MultiPolygon): boolean {
    for (const poly of polygon) {
      for (const ring of poly) {
        if (ring.length < 3) return false;
        
        // Check if polygon is closed
        const first = ring[0];
        const last = ring[ring.length - 1];
        const distance = Math.sqrt(
          Math.pow(first.x - last.x, 2) + Math.pow(first.y - last.y, 2)
        );
        
        if (distance > 1) return false; // 1 pixel tolerance
      }
    }
    
    return true;
  }
  
  // Get polygon area
  static getPolygonArea(polygon: MultiPolygon): number {
    let totalArea = 0;
    
    for (const poly of polygon) {
      for (const ring of poly) {
        if (ring.length < 3) continue;
        
        let area = 0;
        for (let i = 0; i < ring.length; i++) {
          const j = (i + 1) % ring.length;
          area += ring[i].x * ring[j].y;
          area -= ring[j].x * ring[i].y;
        }
        
        totalArea += Math.abs(area) / 2;
      }
    }
    
    return totalArea;
  }
  
  // Get polygon centroid
  static getPolygonCentroid(polygon: MultiPolygon): Point {
    let totalX = 0;
    let totalY = 0;
    let totalArea = 0;
    
    for (const poly of polygon) {
      for (const ring of poly) {
        if (ring.length < 3) continue;
        
        let area = 0;
        let centroidX = 0;
        let centroidY = 0;
        
        for (let i = 0; i < ring.length; i++) {
          const j = (i + 1) % ring.length;
          const cross = ring[i].x * ring[j].y - ring[j].x * ring[i].y;
          area += cross;
          centroidX += (ring[i].x + ring[j].x) * cross;
          centroidY += (ring[i].y + ring[j].y) * cross;
        }
        
        area /= 2;
        if (area !== 0) {
          centroidX /= (6 * area);
          centroidY /= (6 * area);
          
          totalX += centroidX * Math.abs(area);
          totalY += centroidY * Math.abs(area);
          totalArea += Math.abs(area);
        }
      }
    }
    
    if (totalArea === 0) return { x: 0, y: 0 };
    
    return {
      x: totalX / totalArea,
      y: totalY / totalArea
    };
  }
}


7. Contour Rendering and Visualization


7.1 Contour Renderer

// renderers/ContourRenderer.ts
import { MultiPolygon, Point } from '../types/contour';
import { CoordinateTransformer } from '../utils/coordinateTransformer';

export class ContourRenderer {
  private canvas: HTMLCanvasElement;
  private context: CanvasRenderingContext2D;
  private viewport: any;
  
  constructor(canvas: HTMLCanvasElement, viewport: any) {
    this.canvas = canvas;
    this.context = canvas.getContext('2d')!;
    this.viewport = viewport;
  }
  
  // Clear canvas
  clear(): void {
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
  
  // Render contour polygons
  renderContour(
    polygons: MultiPolygon,
    color: [number, number, number],
    options: {
      strokeWidth?: number;
      strokeOpacity?: number;
      fillOpacity?: number;
      dashPattern?: number[];
    } = {}
  ): void {
    const {
      strokeWidth = 2,
      strokeOpacity = 1,
      fillOpacity = 0.3,
      dashPattern = []
    } = options;
    
    this.context.save();
    
    // Set stroke style
    this.context.strokeStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${strokeOpacity})`;
    this.context.lineWidth = strokeWidth;
    
    if (dashPattern.length > 0) {
      this.context.setLineDash(dashPattern);
    }
    
    // Set fill style
    this.context.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${fillOpacity})`;
    
    // Convert polygons to display coordinates
    const displayPolygons = this.convertToDisplayCoordinates(polygons);
    
    // Render each polygon
    for (const polygon of displayPolygons) {
      for (const ring of polygon) {
        if (ring.length < 3) continue;
        
        this.context.beginPath();
        this.context.moveTo(ring[0].x, ring[0].y);
        
        for (let i = 1; i < ring.length; i++) {
          this.context.lineTo(ring[i].x, ring[i].y);
        }
        
        this.context.closePath();
        this.context.fill();
        this.context.stroke();
      }
    }
    
    this.context.restore();
  }
  
  // Render contour outline only
  renderContourOutline(
    polygons: MultiPolygon,
    color: [number, number, number],
    options: {
      strokeWidth?: number;
      strokeOpacity?: number;
      dashPattern?: number[];
    } = {}
  ): void {
    const {
      strokeWidth = 2,
      strokeOpacity = 1,
      dashPattern = []
    } = options;
    
    this.context.save();
    
    this.context.strokeStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${strokeOpacity})`;
    this.context.lineWidth = strokeWidth;
    this.context.fillStyle = 'transparent';
    
    if (dashPattern.length > 0) {
      this.context.setLineDash(dashPattern);
    }
    
    const displayPolygons = this.convertToDisplayCoordinates(polygons);
    
    for (const polygon of displayPolygons) {
      for (const ring of polygon) {
        if (ring.length < 3) continue;
        
        this.context.beginPath();
        this.context.moveTo(ring[0].x, ring[0].y);
        
        for (let i = 1; i < ring.length; i++) {
          this.context.lineTo(ring[i].x, ring[i].y);
        }
        
        this.context.closePath();
        this.context.stroke();
      }
    }
    
    this.context.restore();
  }
  
  // Render brush tool
  renderBrush(
    position: Point,
    size: number,
    operation: 'ADDITIVE' | 'SUBTRACTIVE',
    options: {
      strokeWidth?: number;
      strokeOpacity?: number;
      fillOpacity?: number;
    } = {}
  ): void {
    const {
      strokeWidth = 2,
      strokeOpacity = 1,
      fillOpacity = 0.2
    } = options;
    
    this.context.save();
    
    const displayPos = this.convertPointToDisplay(position);
    const displaySize = size * this.viewport.scale;
    
    // Set colors based on operation
    const color = operation === 'ADDITIVE' ? [0, 255, 0] : [255, 0, 0];
    
    this.context.strokeStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${strokeOpacity})`;
    this.context.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${fillOpacity})`;
    this.context.lineWidth = strokeWidth;
    this.context.setLineDash([5, 5]);
    
    // Draw brush circle
    this.context.beginPath();
    this.context.arc(displayPos.x, displayPos.y, displaySize / 2, 0, 2 * Math.PI);
    this.context.fill();
    this.context.stroke();
    
    // Draw operation indicator
    this.context.setLineDash([]);
    this.context.beginPath();
    
    const indicatorSize = 5;
    if (operation === 'ADDITIVE') {
      // Draw cross for additive
      this.context.moveTo(displayPos.x - indicatorSize, displayPos.y);
      this.context.lineTo(displayPos.x + indicatorSize, displayPos.y);
      this.context.moveTo(displayPos.x, displayPos.y - indicatorSize);
      this.context.lineTo(displayPos.x, displayPos.y + indicatorSize);
    } else {
      // Draw horizontal line for subtractive
      this.context.moveTo(displayPos.x - indicatorSize, displayPos.y);
      this.context.lineTo(displayPos.x + indicatorSize, displayPos.y);
    }
    
    this.context.stroke();
    
    this.context.restore();
  }
  
  // Convert world coordinates to display coordinates
  private convertToDisplayCoordinates(polygons: MultiPolygon): MultiPolygon {
    return polygons.map(polygon => 
      polygon.map(ring => 
        ring.map(point => this.convertPointToDisplay(point))
      )
    );
  }
  
  // Convert single point to display coordinates
  private convertPointToDisplay(point: Point): Point {
    // This is a simplified conversion - you'll need to implement proper
    // coordinate transformation based on your viewport setup
    const worldPoint = CoordinateTransformer.scaledToWorld(point);
    return CoordinateTransformer.worldToDisplay(worldPoint, this.viewport);
  }
  
  // Get mouse position in world coordinates
  getMouseWorldPosition(event: MouseEvent): Point {
    const rect = this.canvas.getBoundingClientRect();
    const displayPoint = {
      x: event.clientX - rect.left,
      y: event.clientY - rect.top
    };
    
    // Convert display coordinates to world coordinates
    // This is a simplified conversion - implement proper inverse transformation
    return {
      x: displayPoint.x / this.viewport.scale - this.viewport.offset.x,
      y: displayPoint.y / this.viewport.scale - this.viewport.offset.y
    };
  }
}

7.2 SVG Contour Renderer

// renderers/SVGContourRenderer.ts
import { MultiPolygon } from '../types/contour';

export class SVGContourRenderer {
  private svgElement: SVGElement;
  
  constructor(svgElement: SVGElement) {
    this.svgElement = svgElement;
  }
  
  // Clear SVG
  clear(): void {
    while (this.svgElement.firstChild) {
      this.svgElement.removeChild(this.svgElement.firstChild);
    }
  }
  
  // Render contour as SVG paths
  renderContour(
    polygons: MultiPolygon,
    color: [number, number, number],
    options: {
      strokeWidth?: number;
      strokeOpacity?: number;
      fillOpacity?: number;
      dashPattern?: number[];
    } = {}
  ): void {
    const {
      strokeWidth = 2,
      strokeOpacity = 1,
      fillOpacity = 0.3,
      dashPattern = []
    } = options;
    
    for (const polygon of polygons) {
      for (const ring of polygon) {
        if (ring.length < 3) continue;
        
        // Create SVG path
        const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        
        // Build path data
        let pathData = `M ${ring[0].x} ${ring[0].y}`;
        for (let i = 1; i < ring.length; i++) {
          pathData += ` L ${ring[i].x} ${ring[i].y}`;
        }
        pathData += ' Z'; // Close path
        
        pathElement.setAttribute('d', pathData);
        pathElement.setAttribute('stroke', `rgb(${color[0]}, ${color[1]}, ${color[2]})`);
        pathElement.setAttribute('stroke-width', strokeWidth.toString());
        pathElement.setAttribute('stroke-opacity', strokeOpacity.toString());
        pathElement.setAttribute('fill', `rgb(${color[0]}, ${color[1]}, ${color[2]})`);
        pathElement.setAttribute('fill-opacity', fillOpacity.toString());
        
        if (dashPattern.length > 0) {
          pathElement.setAttribute('stroke-dasharray', dashPattern.join(','));
        }
        
        this.svgElement.appendChild(pathElement);
      }
    }
  }
  
  // Render brush tool as SVG
  renderBrush(
    position: Point,
    size: number,
    operation: 'ADDITIVE' | 'SUBTRACTIVE',
    options: {
      strokeWidth?: number;
      strokeOpacity?: number;
      fillOpacity?: number;
    } = {}
  ): void {
    const {
      strokeWidth = 2,
      strokeOpacity = 1,
      fillOpacity = 0.2
    } = options;
    
    const color = operation === 'ADDITIVE' ? [0, 255, 0] : [255, 0, 0];
    
    // Create brush circle
    const circleElement = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circleElement.setAttribute('cx', position.x.toString());
    circleElement.setAttribute('cy', position.y.toString());
    circleElement.setAttribute('r', (size / 2).toString());
    circleElement.setAttribute('stroke', `rgb(${color[0]}, ${color[1]}, ${color[2]})`);
    circleElement.setAttribute('stroke-width', strokeWidth.toString());
    circleElement.setAttribute('stroke-opacity', strokeOpacity.toString());
    circleElement.setAttribute('fill', `rgb(${color[0]}, ${color[1]}, ${color[2]})`);
    circleElement.setAttribute('fill-opacity', fillOpacity.toString());
    circleElement.setAttribute('stroke-dasharray', '5,5');
    
    this.svgElement.appendChild(circleElement);
    
    // Create operation indicator
    const lineElement = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    const indicatorSize = 5;
    
    if (operation === 'ADDITIVE') {
      // Draw cross for additive
      lineElement.setAttribute('x1', (position.x - indicatorSize).toString());
      lineElement.setAttribute('y1', position.y.toString());
      lineElement.setAttribute('x2', (position.x + indicatorSize).toString());
      lineElement.setAttribute('y2', position.y.toString());
      lineElement.setAttribute('stroke', `rgb(${color[0]}, ${color[1]}, ${color[2]})`);
      lineElement.setAttribute('stroke-width', '1');
      lineElement.setAttribute('stroke-opacity', strokeOpacity.toString());
      
      this.svgElement.appendChild(lineElement);
      
      const lineElement2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      lineElement2.setAttribute('x1', position.x.toString());
      lineElement2.setAttribute('y1', (position.y - indicatorSize).toString());
      lineElement2.setAttribute('x2', position.x.toString());
      lineElement2.setAttribute('y2', (position.y + indicatorSize).toString());
      lineElement2.setAttribute('stroke', `rgb(${color[0]}, ${color[1]}, ${color[2]})`);
      lineElement2.setAttribute('stroke-width', '1');
      lineElement2.setAttribute('stroke-opacity', strokeOpacity.toString());
      
      this.svgElement.appendChild(lineElement2);
    } else {
      // Draw horizontal line for subtractive
      lineElement.setAttribute('x1', (position.x - indicatorSize).toString());
      lineElement.setAttribute('y1', position.y.toString());
      lineElement.setAttribute('x2', (position.x + indicatorSize).toString());
      lineElement.setAttribute('y2', position.y.toString());
      lineElement.setAttribute('stroke', `rgb(${color[0]}, ${color[1]}, ${color[2]})`);
      lineElement.setAttribute('stroke-width', '1');
      lineElement.setAttribute('stroke-opacity', strokeOpacity.toString());
      
      this.svgElement.appendChild(lineElement);
    }
  }
}


8. Contour Editing Tools


8.1 Contour Editor

// editors/ContourEditor.ts
import { Contour } from '../classes/Contour';
import { PolygonOperations } from '../utils/polygonOperations';
import { MultiPolygon, Point } from '../types/contour';

export class ContourEditor {
  private currentContour: Contour | null = null;
  private history: MultiPolygon[] = [];
  private historyIndex: number = -1;
  private maxHistorySize: number = 50;
  
  // Set current contour for editing
  setContour(contour: Contour): void {
    this.currentContour = contour;
    this.saveToHistory();
  }
  
  // Get current contour
  getContour(): Contour | null {
    return this.currentContour;
  }
  
  // Apply brush stroke
  applyBrushStroke(
    brushPolygons: MultiPolygon,
    operation: 'ADDITIVE' | 'SUBTRACTIVE'
  ): boolean {
    if (!this.currentContour) return false;
    
    const currentPolygons = this.currentContour.getCurrent();
    
    let resultPolygons: MultiPolygon;
    
    if (operation === 'ADDITIVE') {
      resultPolygons = PolygonOperations.union(currentPolygons, brushPolygons);
    } else {
      resultPolygons = PolygonOperations.difference(currentPolygons, brushPolygons);
    }
    
    if (resultPolygons.length === 0) return false;
    
    this.currentContour.updatePolygons(resultPolygons);
    this.saveToHistory();
    
    return true;
  }
  
  // Apply boolean operation
  applyBooleanOperation(
    otherPolygons: MultiPolygon,
    operation: 'UNION' | 'DIFFERENCE' | 'INTERSECTION'
  ): boolean {
    if (!this.currentContour) return false;
    
    const currentPolygons = this.currentContour.getCurrent();
    
    let resultPolygons: MultiPolygon;
    
    switch (operation) {
      case 'UNION':
        resultPolygons = PolygonOperations.union(currentPolygons, otherPolygons);
        break;
      case 'DIFFERENCE':
        resultPolygons = PolygonOperations.difference(currentPolygons, otherPolygons);
        break;
      case 'INTERSECTION':
        resultPolygons = PolygonOperations.intersection(currentPolygons, otherPolygons);
        break;
      default:
        return false;
    }
    
    if (resultPolygons.length === 0) return false;
    
    this.currentContour.updatePolygons(resultPolygons);
    this.saveToHistory();
    
    return true;
  }
  
  // Apply offset
  applyOffset(delta: number): boolean {
    if (!this.currentContour) return false;
    
    const currentPolygons = this.currentContour.getCurrent();
    const resultPolygons = PolygonOperations.offset(currentPolygons, delta);
    
    if (resultPolygons.length === 0) return false;
    
    this.currentContour.updatePolygons(resultPolygons);
    this.saveToHistory();
    
    return true;
  }
  
  // Smooth contour
  smoothContour(iterations: number = 1): boolean {
    if (!this.currentContour) return false;
    
    const currentPolygons = this.currentContour.getCurrent();
    let resultPolygons = currentPolygons;
    
    for (let i = 0; i < iterations; i++) {
      resultPolygons = this.smoothPolygons(resultPolygons);
    }
    
    this.currentContour.updatePolygons(resultPolygons);
    this.saveToHistory();
    
    return true;
  }
  
  // Simplify contour
  simplifyContour(tolerance: number = 1.0): boolean {
    if (!this.currentContour) return false;
    
    const currentPolygons = this.currentContour.getCurrent();
    const resultPolygons = this.simplifyPolygons(currentPolygons, tolerance);
    
    this.currentContour.updatePolygons(resultPolygons);
    this.saveToHistory();
    
    return true;
  }
  
  // Undo last operation
  undo(): boolean {
    if (this.historyIndex <= 0) return false;
    
    this.historyIndex--;
    const previousPolygons = this.history[this.historyIndex];
    
    if (this.currentContour && previousPolygons) {
      this.currentContour.updatePolygons(previousPolygons);
      return true;
    }
    
    return false;
  }
  
  // Redo last undone operation
  redo(): boolean {
    if (this.historyIndex >= this.history.length - 1) return false;
    
    this.historyIndex++;
    const nextPolygons = this.history[this.historyIndex];
    
    if (this.currentContour && nextPolygons) {
      this.currentContour.updatePolygons(nextPolygons);
      return true;
    }
    
    return false;
  }
  
  // Save current state to history
  private saveToHistory(): void {
    if (!this.currentContour) return;
    
    const currentPolygons = this.currentContour.getCurrent();
    
    // Remove any history after current index
    this.history = this.history.slice(0, this.historyIndex + 1);
    
    // Add current state
    this.history.push(JSON.parse(JSON.stringify(currentPolygons)));
    this.historyIndex++;
    
    // Limit history size
    if (this.history.length > this.maxHistorySize) {
      this.history.shift();
      this.historyIndex--;
    }
  }
  
  // Smooth polygons using moving average
  private smoothPolygons(polygons: MultiPolygon): MultiPolygon {
    return polygons.map(polygon => 
      polygon.map(ring => this.smoothRing(ring))
    );
  }
  
  // Smooth a single ring
  private smoothRing(ring: Point[]): Point[] {
    if (ring.length < 3) return ring;
    
    const smoothed: Point[] = [];
    const windowSize = 3;
    
    for (let i = 0; i < ring.length; i++) {
      let sumX = 0;
      let sumY = 0;
      let count = 0;
      
      for (let j = -Math.floor(windowSize / 2); j <= Math.floor(windowSize / 2); j++) {
        const index = (i + j + ring.length) % ring.length;
        sumX += ring[index].x;
        sumY += ring[index].y;
        count++;
      }
      
      smoothed.push({
        x: sumX / count,
        y: sumY / count
      });
    }
    
    return smoothed;
  }
  
  // Simplify polygons using Douglas-Peucker algorithm
  private simplifyPolygons(polygons: MultiPolygon, tolerance: number): MultiPolygon {
    return polygons.map(polygon => 
      polygon.map(ring => this.simplifyRing(ring, tolerance))
    );
  }
  
  // Simplify a single ring using Douglas-Peucker algorithm
  private simplifyRing(ring: Point[], tolerance: number): Point[] {
    if (ring.length < 3) return ring;
    
    const simplified: Point[] = [];
    const keep: boolean[] = new Array(ring.length).fill(false);
    
    // Always keep first and last points
    keep[0] = true;
    keep[ring.length - 1] = true;
    
    this.douglasPeucker(ring, 0, ring.length - 1, tolerance, keep);
    
    for (let i = 0; i < ring.length; i++) {
      if (keep[i]) {
        simplified.push(ring[i]);
      }
    }
    
    return simplified;
  }
  
  // Douglas-Peucker algorithm implementation
  private douglasPeucker(
    ring: Point[],
    start: number,
    end: number,
    tolerance: number,
    keep: boolean[]
  ): void {
    if (end - start <= 1) return;
    
    let maxDistance = 0;
    let maxIndex = start;
    
    const startPoint = ring[start];
    const endPoint = ring[end];
    
    for (let i = start + 1; i < end; i++) {
      const distance = this.pointToLineDistance(ring[i], startPoint, endPoint);
      if (distance > maxDistance) {
        maxDistance = distance;
        maxIndex = i;
      }
    }
    
    if (maxDistance > tolerance) {
      keep[maxIndex] = true;
      this.douglasPeucker(ring, start, maxIndex, tolerance, keep);
      this.douglasPeucker(ring, maxIndex, end, tolerance, keep);
    }
  }
  
  // Calculate distance from point to line
  private pointToLineDistance(point: Point, lineStart: Point, lineEnd: Point): number {
    const A = point.x - lineStart.x;
    const B = point.y - lineStart.y;
    const C = lineEnd.x - lineStart.x;
    const D = lineEnd.y - lineStart.y;
    
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    
    if (lenSq === 0) {
      return Math.sqrt(A * A + B * B);
    }
    
    const param = dot / lenSq;
    
    let xx, yy;
    if (param < 0) {
      xx = lineStart.x;
      yy = lineStart.y;
    } else if (param > 1) {
      xx = lineEnd.x;
      yy = lineEnd.y;
    } else {
      xx = lineStart.x + param * C;
      yy = lineStart.y + param * D;
    }
    
    const dx = point.x - xx;
    const dy = point.y - yy;
    
    return Math.sqrt(dx * dx + dy * dy);
  }
}

8.2 Contour Interpolation

// utils/contourInterpolation.ts
import { MultiPolygon, Point } from '../types/contour';
import { PolygonOperations } from './polygonOperations';

export class ContourInterpolation {
  // Interpolate between two contours
  static interpolate(
    contour1: MultiPolygon,
    contour2: MultiPolygon,
    factor: number
  ): MultiPolygon {
    if (factor <= 0) return contour1;
    if (factor >= 1) return contour2;
    
    // Get centroids
    const centroid1 = PolygonOperations.getPolygonCentroid(contour1);
    const centroid2 = PolygonOperations.getPolygonCentroid(contour2);
    
    // Interpolate centroids
    const interpolatedCentroid = {
      x: centroid1.x + (centroid2.x - centroid1.x) * factor,
      y: centroid1.y + (centroid2.y - centroid1.y) * factor
    };
    
    // Interpolate polygons
    const interpolatedPolygons: MultiPolygon = [];
    
    // Find matching polygons between contours
    const maxPolygons = Math.max(contour1.length, contour2.length);
    
    for (let i = 0; i < maxPolygons; i++) {
      const poly1 = i < contour1.length ? contour1[i] : [];
      const poly2 = i < contour2.length ? contour2[i] : [];
      
      if (poly1.length === 0 && poly2.length === 0) continue;
      
      const interpolatedPolygon = this.interpolatePolygon(poly1, poly2, factor);
      if (interpolatedPolygon.length > 0) {
        interpolatedPolygons.push(interpolatedPolygon);
      }
    }
    
    return interpolatedPolygons;
  }
  
  // Interpolate between two polygons
  private static interpolatePolygon(
    polygon1: Point[][],
    polygon2: Point[][],
    factor: number
  ): Point[][] {
    const interpolatedPolygon: Point[][] = [];
    
    // Find matching rings between polygons
    const maxRings = Math.max(polygon1.length, polygon2.length);
    
    for (let i = 0; i < maxRings; i++) {
      const ring1 = i < polygon1.length ? polygon1[i] : [];
      const ring2 = i < polygon2.length ? polygon2[i] : [];
      
      if (ring1.length === 0 && ring2.length === 0) continue;
      
      const interpolatedRing = this.interpolateRing(ring1, ring2, factor);
      if (interpolatedRing.length > 0) {
        interpolatedPolygon.push(interpolatedRing);
      }
    }
    
    return interpolatedPolygon;
  }
  
  // Interpolate between two rings
  private static interpolateRing(
    ring1: Point[],
    ring2: Point[],
    factor: number
  ): Point[] {
    if (ring1.length === 0) return ring2;
    if (ring2.length === 0) return ring1;
    
    // Resample rings to have the same number of points
    const targetLength = Math.max(ring1.length, ring2.length);
    const resampledRing1 = this.resampleRing(ring1, targetLength);
    const resampledRing2 = this.resampleRing(ring2, targetLength);
    
    // Interpolate between resampled rings
    const interpolatedRing: Point[] = [];
    
    for (let i = 0; i < targetLength; i++) {
      const point1 = resampledRing1[i];
      const point2 = resampledRing2[i];
      
      interpolatedRing.push({
        x: point1.x + (point2.x - point1.x) * factor,
        y: point1.y + (point2.y - point1.y) * factor
      });
    }
    
    return interpolatedRing;
  }
  
  // Resample ring to have specified number of points
  private static resampleRing(ring: Point[], targetLength: number): Point[] {
    if (ring.length === 0) return [];
    if (ring.length === targetLength) return ring;
    
    const resampled: Point[] = [];
    const step = (ring.length - 1) / (targetLength - 1);
    
    for (let i = 0; i < targetLength; i++) {
      const index = i * step;
      const indexFloor = Math.floor(index);
      const indexCeil = Math.min(indexFloor + 1, ring.length - 1);
      const fraction = index - indexFloor;
      
      const point1 = ring[indexFloor];
      const point2 = ring[indexCeil];
      
      resampled.push({
        x: point1.x + (point2.x - point1.x) * fraction,
        y: point1.y + (point2.y - point1.y) * fraction
      });
    }
    
    return resampled;
  }
  
  // Generate intermediate contours between two slices
  static generateIntermediateContours(
    contour1: MultiPolygon,
    contour2: MultiPolygon,
    numIntermediates: number
  ): MultiPolygon[] {
    const intermediates: MultiPolygon[] = [];
    
    for (let i = 1; i < numIntermediates; i++) {
      const factor = i / numIntermediates;
      const intermediate = this.interpolate(contour1, contour2, factor);
      intermediates.push(intermediate);
    }
    
    return intermediates;
  }
}


9. Integration with Medical Viewer


9.1 Contour Manager

// managers/ContourManager.ts
import { StructureSetEntity } from '../classes/StructureSetEntity';
import { ContourEditor } from '../editors/ContourEditor';
import { ContourRenderer } from '../renderers/ContourRenderer';
import { IntelligentBrushTool } from '../tools/IntelligentBrushTool';
import { StructureData, SlicingMode } from '../types/contour';

export class ContourManager {
  private structureSet: StructureSetEntity;
  private editor: ContourEditor;
  private renderer: ContourRenderer;
  private brushTool: IntelligentBrushTool;
  private currentStructure: StructureData | null = null;
  private currentSlice: number = 0;
  private currentSlic
private currentSlicingMode: SlicingMode = SlicingMode.K;
  private isEditing: boolean = false;
  
  constructor(
    structureSet: StructureSetEntity,
    renderer: ContourRenderer
  ) {
    this.structureSet = structureSet;
    this.renderer = renderer;
    this.editor = new ContourEditor();
    this.brushTool = new IntelligentBrushTool();
    
    this.setupBrushTool();
  }
  
  private setupBrushTool(): void {
    this.brushTool.onMouseDown = (event: MouseEvent) => {
      if (!this.isEditing || !this.currentStructure) return;
      
      const worldPos = this.renderer.getMouseWorldPosition(event);
      this.brushTool.onMouseDown(event);
      
      // Get current contour for this slice
      const contour = this.structureSet.getContourAtSlice(
        this.currentStructure.id,
        this.currentSlice,
        this.currentSlicingMode
      );
      
      if (contour) {
        this.editor.setContour(contour);
      }
    };
    
    this.brushTool.onMouseMove = (event: MouseEvent) => {
      if (!this.isEditing || !this.currentStructure) return;
      
      this.brushTool.onMouseMove(event);
      
      // Apply brush stroke to current contour
      const worldPos = this.renderer.getMouseWorldPosition(event);
      const brushPolygons = this.brushTool.getCurrentBrushPolygons();
      
      if (brushPolygons && this.editor.getContour()) {
        this.editor.applyBrushStroke(brushPolygons, this.brushTool.getOperation());
      }
    };
    
    this.brushTool.onMouseUp = (event: MouseEvent) => {
      this.brushTool.onMouseUp(event);
    };
  }
  
  // Set current structure for editing
  setCurrentStructure(structureId: string): void {
    this.currentStructure = this.structureSet.getStructure(structureId);
  }
  
  // Set current slice
  setCurrentSlice(slice: number): void {
    this.currentSlice = slice;
  }
  
  // Set current slicing mode
  setSlicingMode(mode: SlicingMode): void {
    this.currentSlicingMode = mode;
  }
  
  // Start editing mode
  startEditing(): void {
    this.isEditing = true;
  }
  
  // Stop editing mode
  stopEditing(): void {
    this.isEditing = false;
  }
  
  // Set brush size
  setBrushSize(size: number): void {
    this.brushTool.setBrushSize(size);
  }
  
  // Set brush operation
  setBrushOperation(operation: 'ADDITIVE' | 'SUBTRACTIVE'): void {
    this.brushTool.setOperation(operation);
  }
  
  // Render all contours for current slice
  renderContours(): void {
    if (!this.currentStructure) return;
    
    // Get contour for current slice
    const contour = this.structureSet.getContourAtSlice(
      this.currentStructure.id,
      this.currentSlice,
      this.currentSlicingMode
    );
    
    if (contour) {
      const polygons = contour.getCurrent();
      
      // Render contour
      this.renderer.renderContour(
        polygons,
        this.currentStructure.color,
        {
          strokeWidth: 2,
          strokeOpacity: 1,
          fillOpacity: 0.3
        }
      );
      
      // Render brush tool if editing
      if (this.isEditing) {
        const brushPosition = this.brushTool.getCurrentPosition();
        if (brushPosition) {
          this.renderer.renderBrush(
            brushPosition,
            this.brushTool.getBrushSize(),
            this.brushTool.getOperation(),
            {
              strokeWidth: 2,
              strokeOpacity: 1,
              fillOpacity: 0.2
            }
          );
        }
      }
    }
  }
  
  // Undo last operation
  undo(): boolean {
    return this.editor.undo();
  }
  
  // Redo last undone operation
  redo(): boolean {
    return this.editor.redo();
  }
  
  // Apply boolean operation with another structure
  applyBooleanOperation(
    otherStructureId: string,
    operation: 'UNION' | 'DIFFERENCE' | 'INTERSECTION'
  ): boolean {
    if (!this.currentStructure) return false;
    
    const otherStructure = this.structureSet.getStructure(otherStructureId);
    if (!otherStructure) return false;
    
    const otherContour = this.structureSet.getContourAtSlice(
      otherStructure.id,
      this.currentSlice,
      this.currentSlicingMode
    );
    
    if (!otherContour) return false;
    
    const otherPolygons = otherContour.getCurrent();
    
    return this.editor.applyBooleanOperation(otherPolygons, operation);
  }
  
  // Apply offset to current contour
  applyOffset(delta: number): boolean {
    return this.editor.applyOffset(delta);
  }
  
  // Smooth current contour
  smoothContour(iterations: number = 1): boolean {
    return this.editor.smoothContour(iterations);
  }
  
  // Simplify current contour
  simplifyContour(tolerance: number = 1.0): boolean {
    return this.editor.simplifyContour(tolerance);
  }
  
  // Get current structure
  getCurrentStructure(): StructureData | null {
    return this.currentStructure;
  }
  
  // Get all structures
  getAllStructures(): StructureData[] {
    return this.structureSet.getAllStructures();
  }
  
  // Save changes
  saveChanges(): void {
    // Implementation depends on your data persistence strategy
    console.log('Saving contour changes...');
  }
}

9.2 Medical Viewer Integration

// components/MedicalViewer.tsx
import React, { useEffect, useRef, useState } from 'react';
import { StructureSetEntity } from '../classes/StructureSetEntity';
import { ContourManager } from '../managers/ContourManager';
import { ContourRenderer } from '../renderers/ContourRenderer';
import { StructureData, SlicingMode } from '../types/contour';

interface MedicalViewerProps {
  structureSet: StructureSetEntity;
  currentSlice: number;
  slicingMode: SlicingMode;
}

export const MedicalViewer: React.FC<MedicalViewerProps> = ({
  structureSet,
  currentSlice,
  slicingMode
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [contourManager, setContourManager] = useState<ContourManager | null>(null);
  const [currentStructure, setCurrentStructure] = useState<StructureData | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const [brushSize, setBrushSize] = useState(30);
  const [brushOperation, setBrushOperation] = useState<'ADDITIVE' | 'SUBTRACTIVE'>('ADDITIVE');
  
  useEffect(() => {
    if (!canvasRef.current) return;
    
    const canvas = canvasRef.current;
    const renderer = new ContourRenderer(canvas, {
      scale: 1,
      offset: { x: 0, y: 0 }
    });
    
    const manager = new ContourManager(structureSet, renderer);
    setContourManager(manager);
    
    // Set initial structure
    const structures = structureSet.getAllStructures();
    if (structures.length > 0) {
      manager.setCurrentStructure(structures[0].id);
      setCurrentStructure(structures[0]);
    }
  }, [structureSet]);
  
  useEffect(() => {
    if (!contourManager) return;
    
    contourManager.setCurrentSlice(currentSlice);
    contourManager.setSlicingMode(slicingMode);
    
    // Re-render
    renderContours();
  }, [contourManager, currentSlice, slicingMode]);
  
  useEffect(() => {
    if (!contourManager) return;
    
    if (isEditing) {
      contourManager.startEditing();
    } else {
      contourManager.stopEditing();
    }
  }, [contourManager, isEditing]);
  
  useEffect(() => {
    if (!contourManager) return;
    
    contourManager.setBrushSize(brushSize);
  }, [contourManager, brushSize]);
  
  useEffect(() => {
    if (!contourManager) return;
    
    contourManager.setBrushOperation(brushOperation);
  }, [contourManager, brushOperation]);
  
  const renderContours = () => {
    if (!contourManager) return;
    
    contourManager.renderContours();
  };
  
  const handleStructureChange = (structureId: string) => {
    if (!contourManager) return;
    
    contourManager.setCurrentStructure(structureId);
    const structure = structureSet.getStructure(structureId);
    setCurrentStructure(structure || null);
    
    renderContours();
  };
  
  const handleUndo = () => {
    if (!contourManager) return;
    
    if (contourManager.undo()) {
      renderContours();
    }
  };
  
  const handleRedo = () => {
    if (!contourManager) return;
    
    if (contourManager.redo()) {
      renderContours();
    }
  };
  
  const handleBooleanOperation = (
    otherStructureId: string,
    operation: 'UNION' | 'DIFFERENCE' | 'INTERSECTION'
  ) => {
    if (!contourManager) return;
    
    if (contourManager.applyBooleanOperation(otherStructureId, operation)) {
      renderContours();
    }
  };
  
  const handleOffset = (delta: number) => {
    if (!contourManager) return;
    
    if (contourManager.applyOffset(delta)) {
      renderContours();
    }
  };
  
  const handleSmooth = (iterations: number) => {
    if (!contourManager) return;
    
    if (contourManager.smoothContour(iterations)) {
      renderContours();
    }
  };
  
  const handleSimplify = (tolerance: number) => {
    if (!contourManager) return;
    
    if (contourManager.simplifyContour(tolerance)) {
      renderContours();
    }
  };
  
  const handleSave = () => {
    if (!contourManager) return;
    
    contourManager.saveChanges();
  };
  
  const structures = structureSet.getAllStructures();
  
  return (
    <div className="medical-viewer">
      <div className="viewer-controls">
        <div className="structure-selector">
          <label>Structure:</label>
          <select
            value={currentStructure?.id || ''}
            onChange={(e) => handleStructureChange(e.target.value)}
          >
            {structures.map(structure => (
              <option key={structure.id} value={structure.id}>
                {structure.name}
              </option>
            ))}
          </select>
        </div>
        
        <div className="editing-controls">
          <button
            onClick={() => setIsEditing(!isEditing)}
            className={isEditing ? 'active' : ''}
          >
            {isEditing ? 'Stop Editing' : 'Start Editing'}
          </button>
          
          {isEditing && (
            <>
              <div className="brush-controls">
                <label>Brush Size:</label>
                <input
                  type="range"
                  min="1"
                  max="100"
                  value={brushSize}
                  onChange={(e) => setBrushSize(parseInt(e.target.value))}
                />
                <span>{brushSize}</span>
              </div>
              
              <div className="operation-controls">
                <button
                  onClick={() => setBrushOperation('ADDITIVE')}
                  className={brushOperation === 'ADDITIVE' ? 'active' : ''}
                >
                  Add
                </button>
                <button
                  onClick={() => setBrushOperation('SUBTRACTIVE')}
                  className={brushOperation === 'SUBTRACTIVE' ? 'active' : ''}
                >
                  Subtract
                </button>
              </div>
            </>
          )}
        </div>
        
        <div className="edit-controls">
          <button onClick={handleUndo}>Undo</button>
          <button onClick={handleRedo}>Redo</button>
          <button onClick={() => handleOffset(5)}>Expand</button>
          <button onClick={() => handleOffset(-5)}>Shrink</button>
          <button onClick={() => handleSmooth(1)}>Smooth</button>
          <button onClick={() => handleSimplify(1.0)}>Simplify</button>
          <button onClick={handleSave}>Save</button>
        </div>
      </div>
      
      <div className="viewer-canvas">
        <canvas
          ref={canvasRef}
          width={800}
          height={600}
          style={{ border: '1px solid #ccc' }}
        />
      </div>
      
      <div className="structure-list">
        <h3>Structures</h3>
        {structures.map(structure => (
          <div key={structure.id} className="structure-item">
            <span
              className="structure-color"
              style={{
                backgroundColor: `rgb(${structure.color[0]}, ${structure.color[1]}, ${structure.color[2]})`
              }}
            />
            <span className="structure-name">{structure.name}</span>
            {currentStructure?.id === structure.id && (
              <div className="structure-actions">
                <button onClick={() => handleBooleanOperation(structure.id, 'UNION')}>
                  Union
                </button>
                <button onClick={() => handleBooleanOperation(structure.id, 'DIFFERENCE')}>
                  Difference
                </button>
                <button onClick={() => handleBooleanOperation(structure.id, 'INTERSECTION')}>
                  Intersection
                </button>
              </div>
            )}
          </div>
        ))}
      </div>
    </div>
  );
};


10. Complete Working Example


10.1 Main Application

// App.tsx
import React, { useState, useEffect } from 'react';
import { StructureSetEntity } from './classes/StructureSetEntity';
import { MedicalViewer } from './components/MedicalViewer';
import { SlicingMode } from './types/contour';

const App: React.FC = () => {
  const [structureSet, setStructureSet] = useState<StructureSetEntity | null>(null);
  const [currentSlice, setCurrentSlice] = useState(0);
  const [slicingMode, setSlicingMode] = useState<SlicingMode>(SlicingMode.K);
  const [loading, setLoading] = useState(false);
  
  const loadDICOMFile = async (file: File) => {
    setLoading(true);
    
    try {
      const buffer = await file.arrayBuffer();
      const structureSetEntity = new StructureSetEntity('structure-set-1');
      await structureSetEntity.loadFromDICOM(buffer);
      
      setStructureSet(structureSetEntity);
    } catch (error) {
      console.error('Error loading DICOM file:', error);
      alert('Error loading DICOM file');
    } finally {
      setLoading(false);
    }
  };
  
  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      loadDICOMFile(file);
    }
  };
  
  const handleSliceChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setCurrentSlice(parseInt(event.target.value));
  };
  
  const handleSlicingModeChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
    setSlicingMode(event.target.value as SlicingMode);
  };
  
  if (loading) {
    return <div>Loading DICOM file...</div>;
  }
  
  if (!structureSet) {
    return (
      <div className="app">
        <h1>Medical Contour Editor</h1>
        <div className="file-upload">
          <input
            type="file"
            accept=".dcm,.dicom"
            onChange={handleFileUpload}
          />
          <p>Upload a DICOM RT Structure Set file to begin</p>
        </div>
      </div>
    );
  }
  
  return (
    <div className="app">
      <h1>Medical Contour Editor</h1>
      
      <div className="viewer-controls">
        <div className="slice-controls">
          <label>Slice:</label>
          <input
            type="range"
            min="0"
            max="100"
            value={currentSlice}
            onChange={handleSliceChange}
          />
          <span>{currentSlice}</span>
        </div>
        
        <div className="slicing-mode-controls">
          <label>Slicing Mode:</label>
          <select value={slicingMode} onChange={handleSlicingModeChange}>
            <option value={SlicingMode.K}>Axial</option>
            <option value={SlicingMode.J}>Coronal</option>
            <option value={SlicingMode.I}>Sagittal</option>
          </select>
        </div>
      </div>
      
      <MedicalViewer
        structureSet={structureSet}
        currentSlice={currentSlice}
        slicingMode={slicingMode}
      />
    </div>
  );
};

export default App;

10.2 Package.json Dependencies

{
  "name": "medical-contour-editor",
  "version": "1.0.0",
  "description": "Professional medical contour editing application",
  "main": "index.js",
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1",
    "dicom-parser": "^1.8.28",
    "js-angusj-clipper": "^1.0.0",
    "typescript": "^4.9.5",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@types/node": "^18.0.0"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

10.3 CSS Styles

/* styles/MedicalViewer.css */
.medical-viewer {
  display: flex;
  flex-direction: column;
  height: 100vh;
  font-family: Arial, sans-serif;
}

.viewer-controls {
  display: flex;
  gap: 20px;
  padding: 10px;
  background-color: #f5f5f5;
  border-bottom: 1px solid #ddd;
}

.structure-selector,
.editing-controls,
.edit-controls {
  display: flex;
  align-items: center;
  gap: 10px;
}

.brush-controls,
.operation-controls {
  display: flex;
  align-items: center;
  gap: 10px;
}

.viewer-canvas {
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #000;
}

.structure-list {
  width: 300px;
  background-color: #f5f5f5;
  border-left: 1px solid #ddd;
  padding: 10px;
  overflow-y: auto;
}

.structure-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 5px;
  border-bottom: 1px solid #ddd;
}

.structure-color {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: 1px solid #ccc;
}

.structure-name {
  flex: 1;
  font-weight: bold;
}

.structure-actions {
  display: flex;
  gap: 5px;
}

button {
  padding: 5px 10px;
  border: 1px solid #ccc;
  background-color: #fff;
  cursor: pointer;
  border-radius: 3px;
}

button:hover {
  background-color: #f0f0f0;
}

button.active {
  background-color: #007bff;
  color: white;
}

input[type="range"] {
  width: 100px;
}

select {
  padding: 5px;
  border: 1px solid #ccc;
  border-radius: 3px;
}

.app {
  height: 100vh;
  display: flex;
  flex-direction: column;
}

.file-upload {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  gap: 20px;
}

.viewer-controls {
  display: flex;
  gap: 20px;
  padding: 10px;
  background-color: #f5f5f5;
  border-bottom: 1px solid #ddd;
}

.slice-controls,
.slicing-mode-controls {
  display: flex;
  align-items: center;
  gap: 10px;
}

10.4 Usage Instructions

1. Install Dependencies:
	npm install
1. Start Development Server:
	npm start
1. Upload DICOM File:
	- Click "Choose File" and select a DICOM RT Structure Set file
	- The application will parse the file and display available structures
1. Edit Contours:
	- Select a structure from the dropdown
	- Click "Start Editing" to enable brush tools
	- Use the brush size slider to adjust brush size
	- Click "Add" or "Subtract" to change brush operation
	- Click and drag on the canvas to apply brush strokes
1. Advanced Operations:
	- Use "Undo" and "Redo" to navigate through changes
	- Use "Expand" and "Shrink" to offset contours
	- Use "Smooth" to smooth contour edges
	- Use "Simplify" to reduce contour complexity
	- Use boolean operations (Union, Difference, Intersection) with other structures
1. Save Changes:
	- Click "Save" to persist changes (implementation depends on your backend)
This complete implementation provides a professional medical contour editing system with all the features needed for medical imaging applications. The code is modular, well-documented, and follows medical imaging standards.


